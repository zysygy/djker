04/02/2016

First attempt at how to implement core algo

Storing Node Information
-node name (or maybe it is simply sequential)
-# neighbours
-weights to those neighbours
-for graph with n # of nodes, create array G of size n node objects
-node objects consist of name, # of neighbours, array (maybe LL?) of neighbours + their weights + "visited" status

Running Dijk
-create array SP of size n, increasing element indexes are associated with increasing order of nodes in alphanumeric order
-each element initialized to infinity except starting node (0) (either need a lib or a workaround)
-maybe combine this with array G?
--
Rough Pseudocode
for i = 1 to n
    while there are still unvisited nodes
	Add weight of current node to weight to get to neighbour
        Compare and update values of neighbours in array SP if lower
	Find unvisited node in G.neighbours[] with lowest weight in SP
--

Internet says I should do try this with queues

06/02/2016

For representing the graph itself, let's go with an adjacency list, though this solution looks cool http://stackoverflow.com/a/12305436

Vector of arrays is probably best

07/02/2016

Well I lost the assignment deadline. Oh well

2D Vector was the solution. Learned some fancy and syntactically pleasing ways of initializing the vectors.

Core algo is done now, implementation mostly lifted from some pseudocode from Wikipedia

17/02/2016

Busy with CNY and sick past couple weeks
After discussion, we're not going to implement infinity for now due to storage issues, though in future we could try something like QVariant from qt
Let's just get first implementation up and running
